searchState.loadedDescShard("argmin_math", 0, "argmin-math provides mathematics related abstractions …\nAdd a <code>T</code> to <code>self</code>\nReturn the conjugate\n(Pointwise) Divide a <code>T</code> by <code>self</code>\nDot/scalar product of <code>T</code> and <code>self</code>\nIdentity matrix\nCompute the inverse (<code>T</code>) of <code>self</code>\nCompute the l1-norm (<code>U</code>) of <code>self</code>\nCompute the l2-norm (<code>U</code>) of <code>self</code>\nMinimum and Maximum of type <code>T</code>\n(Pointwise) Multiply a <code>T</code> with <code>self</code>\nCreate a random number\nAdd a <code>T</code> scaled by an <code>U</code> to <code>self</code>\nSubtract a <code>T</code> scaled by an <code>U</code> from <code>self</code>\nReturns a number that represents the sign of <code>self</code>.\nSubtract a <code>T</code> from <code>self</code>\nReturn the transpose (<code>U</code>) of <code>self</code>\nDot/scalar product of <code>T</code> and <code>self</code> weighted by W (p^TWv)\nReturn param vector of all zeros (for now, this is a hack. …\nZero for dynamically sized objects\nThe <code>Error</code> type, a wrapper around a dynamic error type.\nAn automatically-implemented extension trait on <code>RngCore</code> …\nAdd a <code>T</code> to <code>self</code>\nGet the backtrace for this Error.\nAn iterator of the chain of source errors contained by …\nReturn conjugate\nWrap the error value with additional context.\n(Pointwise) Divide a <code>T</code> by <code>self</code>\nDot/scalar product of <code>T</code> and <code>self</code>\nAttempt to downcast the error object to a concrete type.\nDowncast this error object by mutable reference.\nDowncast this error object by reference.\nIdentity matrix of size <code>n</code>\nIdentity matrix of same size as <code>self</code>\nFill any type implementing <code>Fill</code> with random data\nReturns the argument unchanged.\nReturn a random value supporting the <code>Standard</code> distribution.\nReturn a bool with a probability <code>p</code> of being true.\nGenerate a random value in the given range.\nReturn a bool with a probability of <code>numerator/denominator</code> …\nCalls <code>U::from(self)</code>.\nCompute the inverse\nReturns true if <code>E</code> is the type held by this error object.\nCompute the l1-norm (<code>U</code>) of <code>self</code>\nCompute the l2-norm (<code>U</code>) of <code>self</code>\nSelect piecewise maximum\nSelect piecewise minimum\nCreate a new error object from a printable error message.\n(Pointwise) Multiply a <code>T</code> with <code>self</code>\nCreate a new error object from any error type.\nGet a random element between min and max,\nThe lowest level cause of this error — this error’s …\nSample a new value, using the given distribution.\nCreate an iterator that generates values using the given …\nAdd a <code>T</code> scaled by an <code>U</code> to <code>self</code>\nSubtract a <code>T</code> scaled by an <code>U</code> from <code>self</code>\nReturns a number that represents the sign of <code>self</code>.\nSubtract a <code>T</code> from <code>self</code>\nTranspose\nFill any type implementing <code>Fill</code> with random data\nDot/scalar product of <code>T</code> and <code>self</code>\nReturn zero(s)\nReturn zero(s)")