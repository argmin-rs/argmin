<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="argmin is a numerical optimization library written entirely in Rust."><meta name="keywords" content="rust, rustlang, rust-lang, argmin"><title>argmin - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../argmin/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><h2 class="location">Crate argmin</h2><div class="block version"><div class="narrow-helper"></div><p>Version 0.5.0</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all argmin's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li></ul></div><div id="sidebar-vars" data-name="argmin" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">argmin</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/argmin/lib.rs.html#8-587" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>argmin is a numerical optimization library written entirely in Rust.</p>
<p><a href="https://docs.rs/argmin/latest/argmin/">Documentation of most recent release</a></p>
<p><a href="https://argmin-rs.github.io/argmin/argmin/">Documentation of main branch</a></p>
<h2 id="design-goals" class="section-header"><a href="#design-goals">Design goals</a></h2>
<p>argmin aims at offering a wide range of optimization algorithms with a consistent interface,
written purely in Rust. It comes with additional features such as checkpointing and observers
which for instance make it possible to log the progress of an optimization to screen or file.</p>
<p>It further provides a framework for implementing iterative optimization algorithms in a
convenient manner. Essentially, a single iteration of the algorithm needs to be implemented and
everything else, such as handling termination, parameter vectors, gradients and Hessians, is
taken care of by the library.</p>
<p>This library uses generics to be as type-agnostic as possible. Abstractions over common math
functions enable the use of common backends such as <code>ndarray</code> and <code>nalgebra</code> via the
<code>argmin-math</code> crate. All operations can be performed with 32 and 64 bit floats. Custom types are
of course also supported.</p>
<h2 id="contributing" class="section-header"><a href="#contributing">Contributing</a></h2>
<p>This crate is looking for contributors!
Potential projects can be found in the
<a href="https://github.com/argmin-rs/argmin/issues">Github issues</a>, but feel free to suggest your own
ideas as well. Besides adding optimization methods and new features, other contributions are
also highly welcome, for instance improving performance, documentation, writing examples (with
real world problems), developing tests, adding observers, implementing a C interface or
<a href="https://github.com/argmin-rs/pyargmin">Python wrappers</a>.
Bug reports (and fixes) are of course also highly appreciated.</p>
<h2 id="algorithms" class="section-header"><a href="#algorithms">Algorithms</a></h2>
<ul>
<li>
<p><a href="solver/linesearch/index.html">Line searches</a></p>
<ul>
<li><a href="solver/linesearch/backtracking/struct.BacktrackingLineSearch.html">Backtracking line search</a></li>
<li><a href="solver/linesearch/morethuente/struct.MoreThuenteLineSearch.html">More-Thuente line search</a></li>
<li><a href="solver/linesearch/hagerzhang/struct.HagerZhangLineSearch.html">Hager-Zhang line search</a></li>
</ul>
</li>
<li>
<p><a href="solver/trustregion/trustregion_method/struct.TrustRegion.html">Trust region method</a></p>
<ul>
<li><a href="solver/trustregion/cauchypoint/struct.CauchyPoint.html">Cauchy point method</a></li>
<li><a href="solver/trustregion/dogleg/struct.Dogleg.html">Dogleg method</a></li>
<li><a href="solver/trustregion/steihaug/struct.Steihaug.html">Steihaug method</a></li>
</ul>
</li>
<li>
<p><a href="solver/gradientdescent/steepestdescent/struct.SteepestDescent.html">Steepest descent</a></p>
</li>
<li>
<p><a href="solver/conjugategradient/cg/struct.ConjugateGradient.html">Conjugate gradient method</a></p>
</li>
<li>
<p><a href="solver/conjugategradient/nonlinear_cg/struct.NonlinearConjugateGradient.html">Nonlinear conjugate gradient method</a></p>
</li>
<li>
<p><a href="solver/newton/index.html">Newton methods</a></p>
<ul>
<li><a href="solver/newton/newton_method/struct.Newton.html">Newton’s method</a></li>
<li><a href="solver/newton/newton_cg/struct.NewtonCG.html">Newton-CG</a></li>
</ul>
</li>
<li>
<p><a href="solver/quasinewton/index.html">Quasi-Newton methods</a></p>
<ul>
<li><a href="solver/quasinewton/bfgs/struct.BFGS.html">BFGS</a></li>
<li><a href="solver/quasinewton/lbfgs/struct.LBFGS.html">L-BFGS</a></li>
<li><a href="solver/quasinewton/dfp/struct.DFP.html">DFP</a></li>
<li><a href="solver/quasinewton/sr1/struct.SR1.html">SR1</a></li>
<li><a href="solver/quasinewton/sr1_trustregion/struct.SR1TrustRegion.html">SR1-TrustRegion</a></li>
</ul>
</li>
<li>
<p><a href="solver/gaussnewton/gaussnewton_method/struct.GaussNewton.html">Gauss-Newton method</a></p>
</li>
<li>
<p><a href="solver/gaussnewton/gaussnewton_linesearch/struct.GaussNewtonLS.html">Gauss-Newton method with linesearch</a></p>
</li>
<li>
<p><a href="solver/goldensectionsearch/struct.GoldenSectionSearch.html">Golden-section search</a></p>
</li>
<li>
<p><a href="solver/landweber/struct.Landweber.html">Landweber iteration</a></p>
</li>
<li>
<p><a href="solver/brent/struct.Brent.html">Brent’s method</a></p>
</li>
<li>
<p><a href="solver/neldermead/struct.NelderMead.html">Nelder-Mead method</a></p>
</li>
<li>
<p><a href="solver/simulatedannealing/struct.SimulatedAnnealing.html">Simulated Annealing</a></p>
</li>
<li>
<p><a href="solver/particleswarm/struct.ParticleSwarm.html">Particle Swarm Optimization</a></p>
</li>
</ul>
<h2 id="examples" class="section-header"><a href="#examples">Examples</a></h2>
<p>Examples for each solver can be found
<a href="https://github.com/argmin-rs/argmin/tree/v0.5.0/examples">here (current released version)</a> and
<a href="https://github.com/argmin-rs/argmin/tree/main/argmin/examples">here (main branch)</a>.</p>
<h2 id="usage" class="section-header"><a href="#usage">Usage</a></h2>
<p>Add this to your <code>Cargo.toml</code>:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
 argmin = &quot;0.5.0&quot;
argmin-math = { version = &quot;0.1.0&quot;, features = [&quot;ndarray_latest-serde,nalgebra_latest-serde&quot;] }</code></pre></div>
<p>or, for the current development version:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
argmin = { git = &quot;https://github.com/argmin-rs/argmin&quot; }
argmin-math = { git = &quot;https://github.com/argmin-rs/argmin&quot;, features = [&quot;ndarray_latest-serde,nalgebra_latest-serde&quot;] }</code></pre></div>
<p>(For which features to select for <code>argmin-math</code> please see the
<a href="https://docs.rs/argmin/latest/argmin-math">documentation</a>.)</p>
<h3 id="features" class="section-header"><a href="#features">Features</a></h3><h4 id="default-features" class="section-header"><a href="#default-features">Default features</a></h4>
<ul>
<li><code>slog-logger</code>: Support for logging using <code>slog</code></li>
<li><code>serde1</code>: Support for <code>serde</code>. Needed for checkpointing and writing parameters to disk as
well as logging to disk.</li>
</ul>
<h4 id="optional-features" class="section-header"><a href="#optional-features">Optional features</a></h4>
<p>The <code>ctrlc</code> feature uses the <code>ctrlc</code> crate to properly stop the optimization (and return the
current best result) after pressing Ctrl+C during an optimization run.</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
 argmin = { version = &quot;0.5.0&quot;, features = [&quot;ctrlc&quot;] }</code></pre></div><h4 id="experimental-support-for-compiling-to-webassembly" class="section-header"><a href="#experimental-support-for-compiling-to-webassembly">Experimental support for compiling to WebAssembly</a></h4>
<p>When compiling to WASM, the feature <code>wasm-bindgen</code> must be used.</p>
<p>WASM support is still experimental. Please report any issues you encounter when using argmin
in a WASM context.</p>
<h4 id="compiling-without-serde-dependency" class="section-header"><a href="#compiling-without-serde-dependency">Compiling without <code>serde</code> dependency</a></h4>
<p>The <code>serde</code> dependency can be removed by turning off the <code>serde1</code> feature, for instance like so:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
 argmin = { version = &quot;0.5.0&quot;, default-features = false, features = [&quot;slog-logger&quot;] }</code></pre></div>
<p>Note that this will remove the ability to write parameters and logs to disk as well as
checkpointing.</p>
<h3 id="running-the-tests-and-building-the-examples" class="section-header"><a href="#running-the-tests-and-building-the-examples">Running the tests and building the examples</a></h3>
<p>The tests and examples require a set of features to be enabled:</p>
<div class="example-wrap"><pre class="language-bash"><code>cargo test --features &quot;argmin/ctrlc,argmin-math/ndarray_latest-serde,argmin-math/nalgebra_latest-serde,argmin/ndarrayl&quot;</code></pre></div><h2 id="defining-a-problem" class="section-header"><a href="#defining-a-problem">Defining a problem</a></h2>
<p>A problem can be defined by implementing the <code>ArgminOp</code> trait which comes with the
associated types <code>Param</code>, <code>Output</code> and <code>Hessian</code>. <code>Param</code> is the type of your
parameter vector (i.e. the input to your cost function), <code>Output</code> is the type returned
by the cost function, <code>Hessian</code> is the type of the Hessian and <code>Jacobian</code> is the type of the
Jacobian.
The trait provides the following methods:</p>
<ul>
<li><code>apply(&amp;self, p: &amp;Self::Param) -&gt; Result&lt;Self::Output, Error&gt;</code>: Applys the cost
function to parameters <code>p</code> of type <code>Self::Param</code> and returns the cost function value.</li>
<li><code>gradient(&amp;self, p: &amp;Self::Param) -&gt; Result&lt;Self::Param, Error&gt;</code>: Computes the
gradient at <code>p</code>.</li>
<li><code>hessian(&amp;self, p: &amp;Self::Param) -&gt; Result&lt;Self::Hessian, Error&gt;</code>: Computes the Hessian
at <code>p</code>.</li>
<li><code>jacobian(&amp;self, p: &amp;Self::Param) -&gt; Result&lt;Self::Jacobian, Error&gt;</code>: Computes the Jacobian
at <code>p</code>.</li>
</ul>
<p>The following code snippet shows an example of how to use the Rosenbrock test functions from
<code>argmin-testfunctions</code> in argmin:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">argmin_testfunctions</span>::{<span class="ident">rosenbrock_2d</span>, <span class="ident">rosenbrock_2d_derivative</span>, <span class="ident">rosenbrock_2d_hessian</span>};
<span class="kw">use</span> <span class="ident">argmin::core</span>::{<span class="ident">ArgminOp</span>, <span class="ident">Error</span>};

<span class="doccomment">/// First, create a struct for your problem</span>
<span class="kw">struct</span> <span class="ident">Rosenbrock</span> {
    <span class="ident">a</span>: <span class="ident">f64</span>,
    <span class="ident">b</span>: <span class="ident">f64</span>,
}

<span class="doccomment">/// Implement `ArgminOp` for `Rosenbrock`</span>
<span class="kw">impl</span> <span class="ident">ArgminOp</span> <span class="kw">for</span> <span class="ident">Rosenbrock</span> {
    <span class="doccomment">/// Type of the parameter vector</span>
    <span class="kw">type</span> <span class="ident">Param</span> <span class="op">=</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span>;
    <span class="doccomment">/// Type of the return value computed by the cost function</span>
    <span class="kw">type</span> <span class="ident">Output</span> <span class="op">=</span> <span class="ident">f64</span>;
    <span class="doccomment">/// Type of the Hessian. Can be `()` if not needed.</span>
    <span class="kw">type</span> <span class="ident">Hessian</span> <span class="op">=</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span><span class="op">&gt;</span>;
    <span class="doccomment">/// Type of the Jacobian. Can be `()` if not needed.</span>
    <span class="kw">type</span> <span class="ident">Jacobian</span> <span class="op">=</span> ();
    <span class="doccomment">/// Floating point precision</span>
    <span class="kw">type</span> <span class="ident">Float</span> <span class="op">=</span> <span class="ident">f64</span>;

    <span class="doccomment">/// Apply the cost function to a parameter `p`</span>
    <span class="kw">fn</span> <span class="ident">apply</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="ident"><span class="self">Self</span>::Param</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident"><span class="self">Self</span>::Output</span>, <span class="ident">Error</span><span class="op">&gt;</span> {
        <span class="prelude-val">Ok</span>(<span class="ident">rosenbrock_2d</span>(<span class="ident">p</span>, <span class="self">self</span>.<span class="ident">a</span>, <span class="self">self</span>.<span class="ident">b</span>))
    }

    <span class="doccomment">/// Compute the gradient at parameter `p`.</span>
    <span class="kw">fn</span> <span class="ident">gradient</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="ident"><span class="self">Self</span>::Param</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident"><span class="self">Self</span>::Param</span>, <span class="ident">Error</span><span class="op">&gt;</span> {
        <span class="prelude-val">Ok</span>(<span class="ident">rosenbrock_2d_derivative</span>(<span class="ident">p</span>, <span class="self">self</span>.<span class="ident">a</span>, <span class="self">self</span>.<span class="ident">b</span>))
    }

    <span class="doccomment">/// Compute the Hessian at parameter `p`.</span>
    <span class="kw">fn</span> <span class="ident">hessian</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="ident"><span class="self">Self</span>::Param</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident"><span class="self">Self</span>::Hessian</span>, <span class="ident">Error</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">t</span> <span class="op">=</span> <span class="ident">rosenbrock_2d_hessian</span>(<span class="ident">p</span>, <span class="self">self</span>.<span class="ident">a</span>, <span class="self">self</span>.<span class="ident">b</span>);
        <span class="prelude-val">Ok</span>(<span class="macro">vec!</span>[<span class="macro">vec!</span>[<span class="ident">t</span>[<span class="number">0</span>], <span class="ident">t</span>[<span class="number">1</span>]], <span class="macro">vec!</span>[<span class="ident">t</span>[<span class="number">2</span>], <span class="ident">t</span>[<span class="number">3</span>]]])
    }
}</code></pre></div>
<p>It is optional to implement any of these methods, as there are default implementations which
will return an <code>Err</code> when called. What needs to be implemented is defined by the requirements
of the solver that is to be used.</p>
<h2 id="running-a-solver" class="section-header"><a href="#running-a-solver">Running a solver</a></h2>
<p>The following example shows how to use the previously shown definition of a problem in a
Steepest Descent (Gradient Descent) solver.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">argmin::core</span>::{<span class="ident">ArgminOp</span>, <span class="ident">Error</span>, <span class="ident">Executor</span>};
<span class="kw">use</span> <span class="ident">argmin::core</span>::{<span class="ident">ArgminSlogLogger</span>, <span class="ident">ObserverMode</span>};
<span class="kw">use</span> <span class="ident">argmin::solver::gradientdescent::SteepestDescent</span>;
<span class="kw">use</span> <span class="ident">argmin::solver::linesearch::MoreThuenteLineSearch</span>;

<span class="comment">// Define cost function (must implement `ArgminOperator`)</span>
<span class="kw">let</span> <span class="ident">cost</span> <span class="op">=</span> <span class="ident">Rosenbrock</span> { <span class="ident">a</span>: <span class="number">1.0</span>, <span class="ident">b</span>: <span class="number">100.0</span> };
  
<span class="comment">// Define initial parameter vector</span>
<span class="kw">let</span> <span class="ident">init_param</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="op">-</span><span class="number">1.2</span>, <span class="number">1.0</span>];
  
<span class="comment">// Set up line search</span>
<span class="kw">let</span> <span class="ident">linesearch</span> <span class="op">=</span> <span class="ident">MoreThuenteLineSearch::new</span>();
  
<span class="comment">// Set up solver</span>
<span class="kw">let</span> <span class="ident">solver</span> <span class="op">=</span> <span class="ident">SteepestDescent::new</span>(<span class="ident">linesearch</span>);
  
<span class="comment">// Run solver</span>
<span class="kw">let</span> <span class="ident">res</span> <span class="op">=</span> <span class="ident">Executor::new</span>(<span class="ident">cost</span>, <span class="ident">solver</span>, <span class="ident">init_param</span>)
    <span class="comment">// Add an observer which will log all iterations to the terminal</span>
    .<span class="ident">add_observer</span>(<span class="ident">ArgminSlogLogger::term</span>(), <span class="ident">ObserverMode::Always</span>)
    <span class="comment">// Set maximum iterations to 10</span>
    .<span class="ident">max_iters</span>(<span class="number">10</span>)
    <span class="comment">// run the solver on the defined problem</span>
    .<span class="ident">run</span>()<span class="question-mark">?</span>;
<span class="comment">// print result</span>
<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">res</span>);</code></pre></div>
<h2 id="observing-iterations" class="section-header"><a href="#observing-iterations">Observing iterations</a></h2>
<p>Argmin offers an interface to observe the state of the solver at initialization as well as
after every iteration. This includes the parameter vector, gradient, Hessian, iteration number,
cost values and many more as well as solver-specific metrics. This interface can be used to
implement loggers, send the information to a storage or to plot metrics.
Observers need to implement the <code>Observe</code> trait.
Argmin ships with a logger based on the <code>slog</code> crate. <code>ArgminSlogLogger::term</code> logs to the
terminal and <code>ArgminSlogLogger::file</code> logs to a file in JSON format. Both loggers also come
with a <code>*_noblock</code> version which does not block the execution of logging, but may drop some
messages in case of a full buffer.
Parameter vectors can be written to disk using <code>WriteToFile</code>.
For each observer it can be defined how often it will observe the progress of the solver. This
is indicated via the enum <code>ObserverMode</code> which can be either <code>Always</code>, <code>Never</code>, <code>NewBest</code>
(whenever a new best solution is found) or <code>Every(i)</code> which means every <code>i</code>th iteration.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">res</span> <span class="op">=</span> <span class="ident">Executor::new</span>(<span class="ident">problem</span>, <span class="ident">solver</span>, <span class="ident">init_param</span>)
<span class="kw">let</span> <span class="ident">res</span> <span class="op">=</span> <span class="ident">res</span>
    <span class="comment">// Add an observer which will log all iterations to the terminal (without blocking)</span>
    .<span class="ident">add_observer</span>(<span class="ident">ArgminSlogLogger::term_noblock</span>(), <span class="ident">ObserverMode::Always</span>)
    <span class="comment">// Log to file whenever a new best solution is found</span>
    .<span class="ident">add_observer</span>(<span class="ident">ArgminSlogLogger::file</span>(<span class="string">&quot;solver.log&quot;</span>, <span class="bool-val">false</span>)<span class="question-mark">?</span>, <span class="ident">ObserverMode::NewBest</span>)
    <span class="comment">// Write parameter vector to `params/param.arg` every 20th iteration</span>
    .<span class="ident">add_observer</span>(<span class="ident">WriteToFile::new</span>(<span class="string">&quot;params&quot;</span>, <span class="string">&quot;param&quot;</span>), <span class="ident">ObserverMode::Every</span>(<span class="number">20</span>))
    <span class="comment">// run the solver on the defined problem</span>
    .<span class="ident">run</span>()<span class="question-mark">?</span>;</code></pre></div>
<h2 id="checkpoints" class="section-header"><a href="#checkpoints">Checkpoints</a></h2>
<p>The probability of crashes increases with runtime, therefore one may want to save checkpoints
in order to be able to resume the optimization after a crash.
The <code>CheckpointMode</code> defines how often checkpoints are saved and is either <code>Never</code> (default),
<code>Always</code> (every iteration) or <code>Every(u64)</code> (every Nth iteration). It is set via the setter
method <code>checkpoint_mode</code> of <code>Executor</code>.
In addition, the directory where the checkpoints and a prefix for every file can be set via
<code>checkpoint_dir</code> and <code>checkpoint_name</code>, respectively.</p>
<p>The following example shows how the <code>from_checkpoint</code> method can be used to resume from a
checkpoint. In case this fails (for instance because the file does not exist, which could mean
that this is the first run and there is nothing to resume from), it will resort to creating a
new <code>Executor</code>, thus starting from scratch.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">res</span> <span class="op">=</span> <span class="ident">Executor::from_checkpoint</span>(<span class="string">&quot;.checkpoints/optim.arg&quot;</span>, <span class="ident">Rosenbrock</span> {})
    .<span class="ident">unwrap_or</span>(<span class="ident">Executor::new</span>(<span class="ident">Rosenbrock</span> {}, <span class="ident">solver</span>, <span class="ident">init_param</span>))
    .<span class="ident">max_iters</span>(<span class="ident">iters</span>)
    .<span class="ident">checkpoint_dir</span>(<span class="string">&quot;.checkpoints&quot;</span>)
    .<span class="ident">checkpoint_name</span>(<span class="string">&quot;optim&quot;</span>)
    .<span class="ident">checkpoint_mode</span>(<span class="ident">CheckpointMode::Every</span>(<span class="number">20</span>))
    .<span class="ident">run</span>()<span class="question-mark">?</span>;</code></pre></div>
<h2 id="implementing-an-optimization-algorithm" class="section-header"><a href="#implementing-an-optimization-algorithm">Implementing an optimization algorithm</a></h2>
<p>In this section we are going to implement the Landweber solver, which essentially is a special
form of gradient descent. In iteration <code>k</code>, the new parameter vector <code>x_{k+1}</code> is calculated
from the previous parameter vector <code>x_k</code> and the gradient at <code>x_k</code> according to the following
update rule:</p>
<p><code>x_{k+1} = x_k - omega * \nabla f(x_k)</code></p>
<p>In order to implement this using the argmin framework, one first needs to define a struct which
holds data specific to the solver. Then, the <code>Solver</code> trait needs to be implemented for the
struct. This requires setting the associated constant <code>NAME</code> which gives your solver a name.
The <code>next_iter</code> method defines the computations performed in a single iteration of the solver.
Via the parameters <code>op</code> and <code>state</code> one has access to the operator (cost function, gradient
computation, Hessian, …) and to the current state of the optimization (parameter vectors,
cost function values, iteration number, …), respectively.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">argmin::core</span>::{<span class="ident">ArgminFloat</span>, <span class="ident">ArgminIterData</span>, <span class="ident">ArgminOp</span>, <span class="ident">Error</span>, <span class="ident">IterState</span>, <span class="ident">OpWrapper</span>, <span class="ident">Solver</span>};
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;serde1&quot;</span>)]</span>
<span class="kw">use</span> <span class="ident">serde</span>::{<span class="ident">Deserialize</span>, <span class="ident">Serialize</span>};
<span class="kw">use</span> <span class="ident">argmin_math::ArgminScaledSub</span>;

<span class="comment">// Define a struct which holds any parameters/data which are needed during the execution of the</span>
<span class="comment">// solver. Note that this does not include parameter vectors, gradients, Hessians, cost</span>
<span class="comment">// function values and so on, as those will be handled by the `Executor`.</span>
<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;serde1&quot;</span>, <span class="ident">derive</span>(<span class="ident">Serialize</span>, <span class="ident">Deserialize</span>))]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Landweber</span><span class="op">&lt;</span><span class="ident">F</span><span class="op">&gt;</span> {
    <span class="doccomment">/// omega</span>
    <span class="ident">omega</span>: <span class="ident">F</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">F</span><span class="op">&gt;</span> <span class="ident">Landweber</span><span class="op">&lt;</span><span class="ident">F</span><span class="op">&gt;</span> {
    <span class="doccomment">/// Constructor</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">omega</span>: <span class="ident">F</span>) -&gt; <span class="self">Self</span> {
        <span class="ident">Landweber</span> { <span class="ident">omega</span> }
    }
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">F</span><span class="op">&gt;</span> <span class="ident">Solver</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Landweber</span><span class="op">&lt;</span><span class="ident">F</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="comment">// `O` always needs to implement `ArgminOp`</span>
    <span class="ident">O</span>: <span class="ident">ArgminOp</span><span class="op">&lt;</span><span class="ident">Float</span> <span class="op">=</span> <span class="ident">F</span><span class="op">&gt;</span>,
    <span class="comment">// `O::Param` needs to implement `ArgminScaledSub` because of the update formula</span>
    <span class="ident">O::Param</span>: <span class="ident">ArgminScaledSub</span><span class="op">&lt;</span><span class="ident">O::Param</span>, <span class="ident">O::Float</span>, <span class="ident">O::Param</span><span class="op">&gt;</span>,
    <span class="ident">F</span>: <span class="ident">ArgminFloat</span>,
{
    <span class="comment">// This gives the solver a name which will be used for logging</span>
    <span class="kw">const</span> <span class="ident">NAME</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;Landweber&quot;</span>;

    <span class="comment">// Defines the computations performed in a single iteration.</span>
    <span class="kw">fn</span> <span class="ident">next_iter</span>(
        <span class="kw-2">&amp;mut</span> <span class="self">self</span>,
        <span class="comment">// This gives access to the operator supplied to the `Executor`. `O` implements</span>
        <span class="comment">// `ArgminOp` and `OpWrapper` takes care of counting the calls to the respective</span>
        <span class="comment">// functions.</span>
        <span class="ident">op</span>: <span class="kw-2">&amp;mut</span> <span class="ident">OpWrapper</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>,
        <span class="comment">// Current state of the optimization. This gives access to the parameter vector,</span>
        <span class="comment">// gradient, Hessian and cost function value of the current, previous and best</span>
        <span class="comment">// iteration as well as current iteration number, and many more.</span>
        <span class="ident">state</span>: <span class="kw-2">&amp;mut</span> <span class="ident">IterState</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>,
    ) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">ArgminIterData</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>, <span class="ident">Error</span><span class="op">&gt;</span> {
        <span class="comment">// First we obtain the current parameter vector from the `state` struct (`x_k`).</span>
        <span class="kw">let</span> <span class="ident">xk</span> <span class="op">=</span> <span class="ident">state</span>.<span class="ident">take_param</span>().<span class="ident">unwrap</span>();
        <span class="comment">// Then we compute the gradient at `x_k` (`\nabla f(x_k)`)</span>
        <span class="kw">let</span> <span class="ident">grad</span> <span class="op">=</span> <span class="ident">op</span>.<span class="ident">gradient</span>(<span class="kw-2">&amp;</span><span class="ident">xk</span>)<span class="question-mark">?</span>;
        <span class="comment">// Now subtract `\nabla f(x_k)` scaled by `omega` from `x_k` to compute `x_{k+1}`</span>
        <span class="kw">let</span> <span class="ident">xkp1</span> <span class="op">=</span> <span class="ident">xk</span>.<span class="ident">scaled_sub</span>(<span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">omega</span>, <span class="kw-2">&amp;</span><span class="ident">grad</span>);
        <span class="comment">// Return new paramter vector which will then be used by the `Executor` to update</span>
        <span class="comment">// `state`.</span>
        <span class="prelude-val">Ok</span>(<span class="ident">ArgminIterData::new</span>().<span class="ident">param</span>(<span class="ident">xkp1</span>))
    }
}</code></pre></div>
<h2 id="license" class="section-header"><a href="#license">License</a></h2>
<p>Licensed under either of</p>
<ul>
<li>Apache License, Version 2.0,
(<a href="https://github.com/argmin-rs/argmin/blob/main/LICENSE-APACHE">LICENSE-APACHE</a> or
<a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>)</li>
<li>MIT License (<a href="https://github.com/argmin-rs/argmin/blob/main/LICENSE-MIT">LICENSE-MIT</a> or
<a href="http://opensource.org/licenses/MIT">http://opensource.org/licenses/MIT</a>)</li>
</ul>
<p>at your option.</p>
<h3 id="contribution" class="section-header"><a href="#contribution">Contribution</a></h3>
<p>Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion
in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above,
without any additional terms or conditions.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="core/index.html" title="argmin::core mod">core</a></div><div class="item-right docblock-short"><p>Argmin Optimizaton toolbox core</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="solver/index.html" title="argmin::solver mod">solver</a></div><div class="item-right docblock-short"><p>Solvers</p>
</div></div></div><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.check_param.html" title="argmin::check_param macro">check_param</a></div><div class="item-right docblock-short"><p>Release an <code>T</code> from an <code>Option&lt;T&gt;</code> if it is not <code>None</code>. If it is <code>None</code>, return an
<code>ArgminError</code> with a message that needs to be provided.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.make_kv.html" title="argmin::make_kv macro">make_kv</a></div><div class="item-right docblock-short"><p>Creates an <code>ArgminKV</code> at compile time in order to avoid pushing to the <code>kv</code> vector.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.trait_bound.html" title="argmin::trait_bound macro">trait_bound</a></div><div class="item-right docblock-short"><p>Reuse a list of trait bounds by giving it a name,
e.g. trait_bound!(CopyAndDefault; Copy, Default);</p>
</div></div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="argmin" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
</body></html>