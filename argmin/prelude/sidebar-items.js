initSidebarItems({"enum":[["ArgminError",""],["CheckpointMode",""],["TerminationReason","Indicates why the optimization algorithm stopped"],["WriterMode",""]],"fn":[["load_checkpoint",""]],"macro":[["check_param","Release an `T` from an `Option<T>` if it is not `None`. If it is `None`, return an `ArgminError` with a message that needs to be provided."],["make_kv","Creates an `ArgminKV` at compile time in order to avoid pushing to the `kv` vector."]],"mod":[["ctrlc","Cross platform handling of Ctrl-C signals."],["file","Output parameter vectors to file"],["finitediff","Finite Differentiation"],["macros","Macros # Macros"],["modcholesky","Modified Cholesky decompositions Modified Cholesky decompositions"]],"struct":[["ArgminBase","Storage for data needed by most solvers"],["ArgminCheckpoint",""],["ArgminIterData","The datastructure which is returned by the `next_iter` method of the `ArgminIter` trait."],["ArgminKV","A simple key-value storage"],["ArgminLogger","Container for `ArgminLog`gers"],["ArgminResult","Return struct for all solvers."],["ArgminSlogLogger","A logger based on `slog`"],["ArgminWriter",""],["Error","The `Error` type, which can contain any failure."],["MinimalNoOperator",""],["NoOperator",""]],"trait":[["ArgminAdd","Add a `T` to `self`"],["ArgminDiv","(Pointwise) Divide a `T` by `self`"],["ArgminDot","Dot/scalar product of `T` and `self`"],["ArgminEye",""],["ArgminInv","Compute the inverse (`T`) of `self`"],["ArgminIter","Main part of every solver: `next_iter` computes one iteration of the algorithm and `init` is executed before these iterations. The `init` method comes with a default implementation which corresponds to doing nothing."],["ArgminLineSearch","Defines a common interface to line search methods. Requires that `ArgminSolver` is implemented for the line search method as well."],["ArgminLog","Defince the interface every logger needs to expose"],["ArgminMul","(Pointwise) Multiply a `T` with `self`"],["ArgminNLCGBetaUpdate","Every method for the update of beta needs to implement this trait."],["ArgminNorm","Compute the l2-norm (`U`) of `self`"],["ArgminOp","This trait needs to be implemented for every operator/cost function."],["ArgminScaledAdd","Add a `T` scaled by an `U` to `self`"],["ArgminScaledSub","Subtract a `T` scaled by an `U` from `self`"],["ArgminSolver","Defines the interface to a solver. Usually, there is no need to implement this manually, use the `argmin_derive` crate instead."],["ArgminSub","Subtract a `T` from `self`"],["ArgminTranspose",""],["ArgminTrustRegion","Defines a common interface to methods which calculate approximate steps for trust region methods. Requires that `ArgminSolver` is implemented as well."],["ArgminWeightedDot","Dot/scalar product of `T` and `self` weighted by W (p^TWv)"],["ArgminWrite","Every writer (which is something that writes parameter vectors somewhere after each iteration) needs to implement this."],["ArgminZero","Return param vector of all zeros (for now, this is a hack. It should be done better)"]]});